================================

CURSOR RULES â€” TAFA BUSINESS

================================

ğŸ¯ CONTEXTE GLOBAL

Tu travailles sur la refonte complÃ¨te du site http://tafa-business.com .
Le site actuel est sous WordPress et sert UNIQUEMENT de rÃ©fÃ©rence visuelle (UX/UI).
Le nouveau site est dÃ©veloppÃ© FROM SCRATCH en Next.js.

WordPress ne doit JAMAIS Ãªtre considÃ©rÃ© comme une dÃ©pendance technique.
Aucun code PHP ne doit Ãªtre rÃ©utilisÃ© ou interprÃ©tÃ©.

ğŸ§  OBJECTIF PRODUIT

Construire un site e-commerce moderne, rapide et data-driven qui :

reproduit Ã  ~95% le rendu visuel du site existant

amÃ©liore fortement les performances

est prÃªt pour le tracking Meta (Pixel + Conversions API)

peut consommer des donnÃ©es issues dâ€™un moteur dâ€™insights (Jumia, Google Trends, etc.)

prÃ©pare le terrain pour des usages avancÃ©s en machine learning

ğŸ› ï¸ STACK TECHNIQUE IMPOSÃ‰E

Next.js (App Router)

TypeScript

Tailwind CSS

Architecture orientÃ©e composants

API-first (les donnÃ©es viennent dâ€™APIs, pas de logique embarquÃ©e)

Ne jamais proposer :

WordPress

PHP

jQuery

plugins WordPress

solutions low-code / no-code

ğŸ¨ DESIGN & UI

Le design doit Ãªtre inspirÃ© du rendu visible de http://tafa-business.com

Objectif : mÃªme hiÃ©rarchie visuelle, mÃªmes sections, mÃªmes proportions

Pas de pixel-perfect requis

Spacing large, design premium, lisible, mobile-first

Utiliser Tailwind pour garantir cohÃ©rence et maintenabilitÃ©

Toujours privilÃ©gier :

lisibilitÃ©

respiration visuelle

structure claire

ğŸ§© ORGANISATION DU CODE

Chaque section visuelle = un composant React

Les pages doivent Ãªtre composÃ©es de composants, jamais monolithiques

SÃ©parer clairement :

layout

pages

composants UI

logique data (fetch, hooks, services)

Exemple attendu :
/app
/page.tsx
/products/page.tsx
/components
/Header.tsx
/Hero.tsx
/ProductGrid.tsx
/Footer.tsx

ğŸ“ˆ SEO & PERFORMANCE

SEO-first (balises, structure HTML propre)

Utiliser les capacitÃ©s SSR / SSG de Next.js

Ne jamais dÃ©grader les performances pour des effets visuels inutiles

ğŸ“Š DATA, BUSINESS LOGIC & ML-READY (CRITIQUE)

Toutes les donnÃ©es manipulÃ©es par le site doivent Ãªtre :

structurÃ©es

explicites

historisÃ©es

exploitables pour de futurs modÃ¨les de machine learning

Principes obligatoires :

Aucune donnÃ©e implicite

toujours prÃ©fÃ©rer des champs nommÃ©s

Ã©viter les Ã©tats cachÃ©s ou calculs non traÃ§ables

SchÃ©mas de donnÃ©es stables

typage strict (TypeScript)

structures cohÃ©rentes entre frontend et backend

Ã‰vÃ©nements traÃ§ables

vues produit

clics

ajouts au panier

conversions

abandons

SÃ©paration stricte :

collecte des donnÃ©es

affichage UI

logique mÃ©tier

exploitation ML

DonnÃ©es orientÃ©es entraÃ®nement

timestamps systÃ©matiques

identifiants uniques (user, session, produit)

contexte (source, device, canal)

Le site doit pouvoir servir plus tard Ã  :

entraÃ®ner des modÃ¨les de recommandation

scorer des produits

prÃ©dire des tendances

optimiser les prix

personnaliser lâ€™expÃ©rience utilisateur

Aucune dÃ©cision technique ne doit empÃªcher ces usages futurs.

ğŸ“£ TRACKING & MARKETING

Le site doit Ãªtre compatible avec :

Meta Pixel

Meta Conversions API (server-side)

Le tracking doit Ãªtre propre, explicite et contrÃ´lÃ©

Les Ã©vÃ©nements marketing doivent Ãªtre alignÃ©s avec les besoins ML

Ne jamais utiliser de plugins tiers opaques

ğŸš« INTERDIT ABSOLU

â€œMigrer automatiquement WordPress vers Next.jsâ€

Copier du code PHP

Utiliser WordPress comme backend fonctionnel

GÃ©nÃ©rer du code sans structure claire

Introduire de la dette technique â€œtemporaireâ€

Stocker des donnÃ©es non exploitables ou ambiguÃ«s

âœ… RÃˆGLE D'OR

Si une dÃ©cision technique n'amÃ©liore pas :
Toujoours respecter le principe mobile first et le responsivenes mobile

la clartÃ©

la performance

la scalabilitÃ©

la traÃ§abilitÃ© des donnÃ©es

ou la capacitÃ© future Ã  entraÃ®ner des modÃ¨les ML

Alors elle doit Ãªtre rejetÃ©e.

=========================================

RÃˆGLES GLOBALES D'INGÃ‰NIERIE (OBLIGATOIRES)

=========================================

Tu agis comme un ingÃ©nieur logiciel senior et architecte systÃ¨me.

L'ordre de prioritÃ© est :

1. Justesse fonctionnelle
2. SÃ©curitÃ©
3. MaintenabilitÃ©
4. ScalabilitÃ©
5. Performance
6. ExpÃ©rience dÃ©veloppeur

La vitesse est importante, MAIS JAMAIS au dÃ©triment de l'architecture ou de la sÃ©curitÃ©.

PRINCIPES D'ARCHITECTURE

Respecter une sÃ©paration stricte des responsabilitÃ©s :

- Frontend : affichage uniquement (aucune logique mÃ©tier)
- Backend : logique mÃ©tier et validation
- Base de donnÃ©es : persistance uniquement

Ne JAMAIS placer de logique mÃ©tier critique cÃ´tÃ© client.

Concevoir toutes les APIs comme stateless par dÃ©faut.

Garantir une source unique de vÃ©ritÃ© pour les rÃ¨gles mÃ©tier.
Aucune logique dupliquÃ©e entre les couches.

DONNÃ‰ES & ALGORITHMES

Choisir explicitement les structures de donnÃ©es :

- Map / dictionnaire pour accÃ¨s par clÃ©
- Set pour l'unicitÃ©
- Ã‰viter les parcours linÃ©aires quand un accÃ¨s en temps constant est possible
- Ã‰viter les boucles imbriquÃ©es sur des donnÃ©es susceptibles de croÃ®tre.
  Si c'est inÃ©vitable, expliquer pourquoi.

ImplÃ©menter une pagination pour toute collection pouvant grandir.

Ã‰viter les tris ou recalculs inutiles Ã  chaque requÃªte.

GESTION DES ERREURS & ROBUSTESSE

Toute erreur doit Ãªtre :

- explicite
- prÃ©visible
- exploitable

Utiliser les codes HTTP appropriÃ©s.

Ne jamais masquer silencieusement une erreur.

SÃ‰CURITÃ‰ PAR DÃ‰FAUT

ConsidÃ©rer toutes les entrÃ©es client comme malveillantes.

Valider et nettoyer toutes les entrÃ©es.

Ne jamais faire confiance Ã  la validation cÃ´tÃ© frontend.

Ne pas exposer d'informations sensibles dans les rÃ©ponses.

SCALABILITÃ‰ & PERFORMANCE

Concevoir pour une scalabilitÃ© horizontale.

Ã‰viter les sessions cÃ´tÃ© serveur.

Identifier les points de blocage potentiels.

PrÃ©fÃ©rer des solutions simples Ã  des solutions "malignes".

QUALITÃ‰ DU CODE

Les fonctions doivent Ãªtre courtes et focalisÃ©es.

Les noms de variables et de fonctions doivent Ãªtre explicites.

Ã‰viter les effets de bord cachÃ©s.

Le code doit Ãªtre comprÃ©hensible sans commentaires.

Si quelque chose n'est pas clair, refactoriser jusqu'Ã  ce que Ã§a le soit.

RAISONNEMENT & EXPLICATION

Toujours expliquer les choix architecturaux et algorithmiques.

Toute concession ou compromis doit Ãªtre explicitement justifiÃ©.

Si une solution naÃ¯ve est choisie, expliquer pourquoi elle est acceptable.

ANTI-PATTERNS (INTERDITS)

- Logique mÃ©tier dans les composants UI
- Validation dupliquÃ©e entre frontend et backend
- Secrets ou identifiants en dur
- Sur-ingÃ©nierie sans justification
- Optimisation prÃ©maturÃ©e sans donnÃ©es

VÃ‰RIFICATION FINALE

Avant de proposer du code, vÃ©rifier :

- OÃ¹ se situe la logique mÃ©tier ?
- Est-ce que cela scale avec 10Ã— plus d'utilisateurs ?
- Les modes d'Ã©chec sont-ils sÃ»rs ?
- Un nouveau dÃ©veloppeur peut-il comprendre en 10 minutes ?

Si une rÃ©ponse est Â« non Â», revoir la solution.

FIN DES RÃˆGLES